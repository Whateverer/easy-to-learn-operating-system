# easy-to-learn-operating-system
인프런 그림으로 쉽게 배우는 운영체제 정리

# 운영체제 들어가기
## 운영체제 개요
컴퓨터에 운영체제가 없어도 동작하는가?
- 동작한다. 하지만 처음 설계한 기능대로만 동작할 뿐 기능을 더 추가할 수 없다.
### 운영체제가 하는 일
1. 프로세스 관리 
2. 메모리 관리 -
모든 프로그램은 메모리 위에서 동작
3. 하드웨어 관리 - 
운영체제는 사용자의 하드웨어에 대한 직접적인 접근을 막는다.
4. 파일 시스템 관리 -
하드디스크에 많은 파일들의 효율적인 저장과 관리를 한다.

## 운영체제의 역사
### 운영체제 역사
- 1940년대 - 애니악 발명, 어떻게하면 CPU를 최대한 효율적으로 사용할 수 있을까?
- 1950년대 초 - 진공관과 전선으로 만들어진 논리회로를 아주 작은 크기로 만든 직접 회로(IC) 개발
- 1950년대 중후반 - 컴퓨터가 여러 개의 요청을 한 번에 해결 (싱글스트림 배치시스템) -> CPU 사용성 높아짐
- 1960년도 - 싱글스트림 배치시스템의 한계 극복 -> 프로그램을 순서대로 하나씩 실행하는 것이 아니라 메모리에 여러 프로그램을 올려놓고 시간을 나누어서 빠르게 돌아가면서 실행 (시분할 시스템), UNIX(멀티 프로그래밍, 다중 사용자, 파일시스템 구현)
- 1960년도의 문제 - 1. 메모리 침범 이슈 2. 어느 메모리 위치에서 실행되는지 모름
- 1970년도 이후 - 개인용 컴퓨터의 시대

## 운영체제의 구조
### 운영체제의 구조
운영체제의 핵심은 커널
### 커널
- 프로세스와 메모리, 저장장치를 관리하는 핵심적인 기능 담당.
- 사용자는 운영체제의 커널에 직접 접근할 수 없고 인터페이스를 통해 접근 가능
- 어플리케이션은 시스템 콜을 통해 커널에 접근 가능
- 커널은 사용자로부터 자신을 보호하기 위한 시스템 콜이라는 인터페이스를 가지고 있다.
- 하드웨어와 커널의 인터페이스는 드라이버를 사용 (하드웨어 제조사에서 드라이브를 만들어 제공)
### 인터페이스
- GUI(Graphic User Interface): 그래픽으로 된 인터페이스   
- CLI(Command-line Interface): 텍스트를 이용해 커널과 상호작용

## 컴퓨터 하드웨어와 구조
### 컴퓨터 하드웨어와 구조
#### 폰 노이만 구조
- 오늘날 대부분의 컴퓨터는 프로그램 내장 방식의 폰 노이만 구조를 하고 있다.
- 예전에는 에니악과 같이 하드웨어로 프로그램을 만들어서 프로그램이 달라질 때마다 매번 스위치와 배선을 다시 조정해야 했음
- 이를 해결하기 위해 폰 노이만은 CPU와 메모리를 두고 이들 사이를 버스(데이터를 전달하는 통로)로 연결
### 컴퓨터 하드웨어
메인보드 - 다른 하드웨어를 연결하는 장치, 장치 간에 데이터를 전송하는 건 메인보드의 버스가 담당한다. 폰 노이만 구조라 CPU와 메모리가 필수
### CPU 구조
CPU(Central Processing Unit) 중앙처리장치 
- 산술논리 연산장치: 실제로 데이터 연산 담당
- 제어 장치: 모든 장치들의 동작을 지시하고 제어하는 장치
- 레지스터: CPU내에서 계산을 위해 임시로 보관하는 장치(변수라고 생각하면 됨)
### 메모리 종류
- RAM(Random Access Memory): 랜덤으로 데이터를 읽어도 저장된 위치와 상관없이 읽는 속도가 같다. 전력이 끊기면 데이터를 잃어버리기 때문에 메인 메모리로 사용됨
- ROM(Read Only Memory): 전력이 끊겨도 데이터를 계속 보관할 수 있지만 데이터를 한 번 쓰면 수정이 불가능, 컴퓨터의 부팅과 관련된 바이오스를 저장하는 데에 주로 쓰임

## 컴퓨터의 부팅과정
### 부팅과정
1. 컴퓨터의 전원을 누르면 ROM에 저장된 바이오스가 실행됨
2. 바이오스는 전원, CPU, 메모리, 키보드, 마우스, 하드디스크 등 주요 하드웨어에 이상이 없는지를 체크
3. 만약 주요장치에 이상이 있다면 오류음을 내면서 부팅이 이뤄지지 않고 이상이 없다면 하드디스크에 있는 마스터 부트 레코드에 저장된 부트로더를 메모리로 가져와서 실행한다.
4. 운영체제를 불러온다. (만약 운영체제가 여러개라면 어느 것을 실행할지 선택하는 화면이 나옴)
5. 이제부터 실행되는 모든 응용 프로그램은 메모리에 올라가서 운영체제가 관리한다.

## 인터럽트
### 인터럽트
CPU가 입출력장치에 데이터를 읽거나 쓰는 상황
CPU는 입출력 작업이 들어오면 입출력 관리자에게 입출력 명령을 내린다.
CPU입장에서는 입출력 작업이 언제 끝날지 알 수 없기 때문에 주기적으로 확인해준다. 
- 이러한 방식을 폴링(Polling) 방식이라고 한다.
폴링 방식의 단점은 주기적으로 CPU가 확인해줘야 하니 성능이 좋지 않다.
#### 인터럽트
- 인터럽트는 폴링 방식의 단점을 해결한 방식이다.
- CPU가 입출력 관리자에게 입출력 명령을 내리고 자기는 다른 작업을 계속한다. 입출력 관리자는 입출력이 완료됐을 때 CPU에게 신호를 주고 CPU는 그 신호를 받아 인터럽트 서비스 루틴(ISR)을 실행시켜 작업을 완료한다.
- 인터럽트 서비스 루틴: 특정 인터럽트가 들어오면 그 인터럽트를 처리하는 함수
- 인터럽트는 비동기적으로 동작하기 때문에 성능에 이점이 있다.
- 인터럽트는 하드웨어 방식과 소프트웨어 방식 두 가지가 있다.
  - 하드웨어 방식: 입출력 등과 같은 인터럽트가 있다.
  - 소프트웨어 방식: 사용자 프로그램에서 발생한 인터럽트 ex) 유효하지 않은 메모리에 접근, 0으로 나누는 명령어

## 프로그램과 프로세스
### 프로그램과 프로세스
#### 프로그램
- 하드디스크 등과 같은 저장장치에 저장된 명령문의 집합체. 
- 애플리케이션, Windows 운영체제에서는 .exe의 모습을 하고 있다.
- 프로그램은 컴퓨터 입장에서 하드디스크(저장 장치)만 사용하는 수동적인 존재.
#### 프로세스
- 프로세스 == 실행중인 프로그램. 
- 실행중인 프로그램은 하드디스크에 저장된 프로그램이 메모리에 올라갔을 때 (RAM) 실행중인 프로그램, 즉 프로세스라고 부른다.
- 프로세스는 메모리도 사용, 운영체제의 CPU 스케줄링 알고리즘에 따라 CPU도 사용, 필요에 따라 입출력을 하기 때문에 능동적인 존재.
#### 프로세스의 구성요소
- Code 영역: 자신을 실행하는 코드가 저장되어 있음
- Data 영역: 전역 변수와 static 변수가 저장되어 있음
- Heap 영역: 프로그래머가 동적으로 메모리를 할당하는 데 쓰임, C언어에서 malloc() - 힙 영역에 메모리 공간을 할당, free() - 할당된 메모리 공간 해제
- Stack 영역: 지역 변수와 함수 호출을 했을 때 필요한 정보들이 저장됨
#### 우리가 만든 코드가 메모리에 올라가 프로세스가 되는 과정
예제는 C언어로 진행된다.
1. C언어는 컴파일 언어이기 때문에 먼저 컴파일을 한다.
- 컴파일 과정
  - 전처리기를 거쳐 매크로로 정읳나 숫자를 치환하고 필요한 파일을 불러온다.
  - 전처리기를 거치면 파일의 확장자는 .i가 된다.
  - 컴파일러가 컴파일을 해준다.
  - 컴파일을 마치면 고수준인 C언어를 저수준인 어셈블리어로 바꿔준다.
  - 컴파일러를 거치면 파일의 확장자는 .s가 된다.
  - 어셈블러가 어셈블리어를 기계어로 바꿔진다.
  - 이제 파일은 0과 1로 이루어진 기계어로 구성되고 파일의 확장자는 .o가 된다.
  - 마지막으로 링커가 링킹을 한다. 여러가지 라이브러리나 다른 소스코드를 링킹한다.
  - 링킹을 거치면 우리의 파일의 확장자는 .exe로 변환이 된다.
2. .exe 파일을 더블클릭 하게되면 하드디스크에 있는 우리의 파일이 메모리에 올라가게 되고 이렇게 올라간 프로그램은 프로세스라는 새로운 이름으로 불리게 된다.
3. 이 프로세스는 이제부터 운영체제에 의해 관리된다.
4. CPU 관점에서 코드를 실행한다.
- CPU 관점
  - CPU내의 제어장치가 C언어의 변수를 메모리에 저장시킨다.
  - 이 메모리에 저장된 값을 edx, eax 레지스터로 가져온다.
  - 제어 장치가 레지스터에 저장된 변수의 값을 더하라는 명령을 한다.
  - 산술논리 연산장치가 변수를 더하고 그 결과를 eax 레지스터에 저장한다.
  - 다시 제어장치가 eax에 저장된 결과 값을 가져와서 메모리에 저장시킨다.

## 멀티 프로그래밍과 멀티 프로세싱
### 유니프로그래밍, 멀티 프로그래밍, 멀티 프로세싱
#### 유니프로그래밍
메모리에 오직 하나의 프로세스가 올라온 것을 말한다.
#### 멀티프로그래밍
메모리에 여러 개의 프로세스가 올라온 것을 말한다.
#### 멀티프로세싱
유니프로그래밍과 멀티프로그래밍은 메모리의 관점으로 정의했다면, 멀티프로세싱은 CPU 관점으로 정의한 것이다.
멀티프로세싱은 CPU가 여러 개의 프로세스를 처리하는 것을 말한다. 

- 오늘 날의 OS는 멀티프로그래밍과 멀티프로세싱 두 개가 공존한다.
- 메모리에는 여러 개의 프로그램이 올라오는 멀티프로그래밍이 있고 시분할 처리로 CPU가 각각의 프로세스를 짧은 시간 동안 교대로 실행하는 멀티 프로세싱이 있다.
- 과거에는 메모리의 크기가 작아서 멀티프로그래밍이 불가능했다. 
  - 이 때는 유니프로그래밍을 하면서 멀티프로세싱을 했다.

#### 스와핑
메모리에 있는 데이터를 다른 저장장치로 보내고 다른 저장장치에서 메모리로 올리는 것

## PCB
### PCB(Process Control Block)
프로그램이 메모리에 올라가서 실행중인 상태를 프로세스라고 한다.
프로세스가 만들어지면 운영체제는 해당 프로세스의 정보를 가지고 있는 PCB를 만들고 저장한다.
PCB들은 연결리스트라는 자료구조로 저장된다. 
운영체제는 프로세스가 종료되면 연결리스트에서 해당 PCB를 제거한다.
#### 연결리스트
연결리스트는 각각의 데이터가 다음 데이터를 연결하는 구조로 되어있는 자료구조
#### PCB의 구조
- 포인터: 부모와 자식 프로세스에 대한 포인터, 할당된 자원에 대한 포인터, 프로세스의 한 상태에서 다른 상태로 전환될 때 저장하는 포인터를 가지고 있다.
- 프로세스 상태: 현재 프로세스의 5가지 상태(생성, 준비, 실행, 대기, 완료)를 나타냄
- 프로세스 ID: 프로세스를 식별하기 위한 숫자
- 프로그램 카운터: 다음에 실행될 명령어의 주소를 포함하는 프로그램 카운터를 저장, CPU가 시분할로 처리되어 중간에 다른 프로세스가 실행될 수 있어 어디까지 진행했는지를 기억해야 함.
- 레지스터 정보: 프로세스가 실행될 때 사용했던 레지스터가 저장, 프로그램 카운터와 마찬가지로 CPU를 뺏기고 다시 시작할 때 이전에 사용하던 값을 복구하기 위한 용도
- 메모리 관련 정보: 프로세스가 메모리에 있는 위치 정보, 메모리 침범을 막기 위한 경계 레지스터값 등이 저장
- CPU 스케줄링 정보: CPU 스케줄링에 필요한 우선순위, 최종 실행시간, CPU 점유시간 등이 저장